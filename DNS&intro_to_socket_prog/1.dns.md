Problem with IP addresses being the norm to search in the internet -> bad experience for human to browse the internet

develop a service which converts a domain name send it to some special server and get back its ip address for the browser to actual hit the destination

This special server is the DNS(domain name service/system)

Now lets how to design this system?

Lets say i take a huge server somehwere in the world with petabytes of storage, ram etc put all the mapping, db , code etc in it with the domain name of lets say dns.com and so if anyone in the world wants to visit any website point your browser or os to this particular dns.com server and get the ip address as answer back, is this good design?

Latency and cost would be very high

Most importantly any time we have a single server no matter how powerful it is , we can never rely on it, it can always crash, and for smtg like dns it is very important to not crash and this becomes a single point of failure

So lets remove the single point of failure

DNS is designed in a layered/heirarchy architecture

Even if you type "google.com." google opens properly, the dot at the end is optional, the browser adds it automatically and the dot represents the root server, .com is the TLD(top level domain server) and the complete name except the dot is the authoritative name server(ANS)

. (root)->purpose is to know about TLDs where they are how many there are etc

.com->tld-com.com .xyz->tld-xyz.com .ai->tld-ai.com   (TLDs)->to know about ANS

google.com->ns1.com youtube.com->ns2.com (ANS)->actual mapping b/w domain name and ip address is stored at this level

first request goes to root which gives it the tld then the tld gives the ans which has the mapping

companies/websites like godaddy, google domains, etc called registrars have set up and maintain ANS around the world and we buy domain names from them and then associate an ip with it, they add the mapping into the db and the ANS updates the TLD about a new addition so when someone comes looking for the website TLD knows which ANS to tell it to go

if you can see the above examples, even the tld and ans are nothing but domain names so the request to go to the next layer actual consists of two requests, one to convert that layer's domain name to ip and then to get the next layer's domain, but then in this case we hit a problem where to ask the ANS(e.g.,ns1.com) we need its ip address but to find its ip address we have to ask same name server, we are stuck in a loop.
Solution - A glue record, it is an Ip address for a name server that is provided by the parent DNS server along with the domain name/delegation.
Our computer's resolver asks a DNS root server, who handles .com TLD?, root server's response includes the names of the .com TLD servers and their IP addresses. Resolver now contacts one of the .com TLD servers and asks who is the ANS for example.com? The .com TLD server looks up example.com, it sees that the name server is ns1.example.com, since ns1 is subdomain of the domain it serves TLD server provides a glue record(ip address for ns1.example.com), now resolver directly contacts ns1 using its ip and asks for the ip for www.example.com. The ANS ns1 responds with the final IP address for www.example.com

But why are there domain names for tld, ans, root in the first place since no common human is going to interact with it?
IP addresses can change, a server might be moved to a new data center, its network infra might be updated or replaced entirely, if everyone knew the server by its ip address, any change would require updating the config of millions of DNS resolvers worldwide causing a logistical nightmare and massive outages, by using a domain name the admin can change the underlying IP address, domain name stays the same.
Core internet services like root and TLD servers dont run on a single computer, they are massive distributed networks spread across the globe for reliability and speed, a technology called Anycast is used where many diff servers share the same IP address, when you send a request to that IP, it's automatically routed to the server that is geographically closest to you, the domain name acts as the single, consistent name for this entire global network of servers.
In case of a hardcoded ip address for each server, the server owner changes their ip, they now have to notify evevry single ISP and company in the world that uses thier server, the admin for every one of those millions of resolvers must manually edit their config files to push the updates, on the other hand with domain names,
1.A new name server is configured and starts running at the new IP address, its a perfect copy of the old one and is ready to answer DNS queries
2.The domain owner logs into their domain registrar and updates the IP address for their name server, the registrar sends this update to the central domain registry(e.g.,verisign which manages .com)
3.The registry updates the glue record, however, dns servers all over the world will have the old glue records stred in their cache, this cache is controlled by a setting called Time To Live(TTL). During this TTL period (which can be hours), some traffic will go to the new IP and some will go to the old IP, so both servers must be running simultaneously
4.Only after the TTL has expired and all traffic has naturally shifted to the new IP address is it safe to turn off the old server

How are dns info and glue records stored?
DNS ifo for a domain is stored as a collection of records(or dns recordsare the individual lines of instruction in a DNS database that provide info about a domain, each record has a specific type that tells servers what kind of info it is
1.A and AAAA records(address records)(Most fundamental DNS records, A record maps a domain name to an IPv4 address while AAAA maps to IPv6 address)
2.CNAME record(canonical name)(acts as an alias, pointing one domain name to another canonical or primary domain name instead of directly to an IP address, browser then looks up DNS records for the primary domain, it is useful when you want multiple subdomains like www.example.com,store.example.com to point to the same server)
3.MX record(mail exchanger)(specifies mail servers that are responsible for accepting email on behalf of a domain, includes a priority no. to indicate which server to try first. WHen we send an email to person@example.com, email service looks up the mx record for example.com to find address of its mail server)
4.TXT record(text)(allows domain administrator to store arbitrary text, originally used for human readable notes but is now primarily used for machine-readable data, most common use case today is for security and verification, services like Google workspace or Microsoft 365 will ask you to add a specific TXT record to your domain to prove you own nit, its also used for email security protocols like SPF(Sender policy framework) and DKIM(domainkeys identified mail) to prevent spoofing)
5.NS record(name server)(delegates a domain or subdomain to a set of ANS, these are the servers that store the actual zone file and all its records for that domain)
6.SOA record(start of authority)(critical admin record that exists at the beginning of every zone file, contains important info about the zone including primary name server, email of domain admin, the domain 's serial number and variour timers to how often zone should be refreshed, used to manage how a domain's DNS info is replicated between name servers, serial number is incremented with each changes to the zone file signalling to secondary servers that they need to update their copy)
7.PTR record(pointer)(its the reverse of a record, it maps an IP address back to a domain name, this process is known as a reverse DNS lookup, primarily use for security and logging, many email servers will perform a reverse DNS lookup on an incoming connection, if the IP address dosent have a PTR record of if it dosent match the sending domain, email may be marked as spam or rejected, helps verify that the server is who it claims to be)) iniside its zone file(plain text file stored on an ANS server that contains all the DNS records for a single domain(or zone), when you make a change to your DNS settings at a registrar, you are editing the contents of this file) on its designated authoratative name server
A glue record isnt a special type of record, its a std A or AAAA record stored in the parent zone file

why does this layer architecture work?
Insatead of one server handling every request, load is distributed across millions of servers(root, tld, ans). caching at every layer prevents root servers from being overwhelmed. The central root server dosent need to know about evevry server in the world it only needs to know who is in charge of the next layer down, in turn the tld or .com registry dosent need to know about www.google.com it just needs to know who is in charge of the google.com domain, this also prevents naming conflicts as google and microsoft can both have a server named mail, mail.google.com, mail.microsoft.com. But in cn nothing is perfect dns has several drawbacks centered around its originl design which prioritized openness over security,
1.DNS spoofing(cache poisoning)(An attacker can trick a DNS resolver into accepting a forged response placing malicious IP address into its cache, when user tries to visit their bank's website the poisoned resolver sneds then to a fake phishing site instead)
2.DNS amplification Attacks(This is a type of  Distributed Denial of service (DDOS) attack where an attacker sends a small query to a DNS server but forges the return address to be that of threir victim, the DNS server then sends them a much larger repsponse to the victim by doing this with many servers they can flood the victim with traffic and take their service offline)
3.Domain hijacking(Attackers can gain unauthorized access to the domain's registration account and change the NS records. This allows them to redirect the entire domain's traffic)
4.By default dns queries are sent in plaintext(unencrypted), so anyone between your computer and DNS resolver such as ISP, network admin or anyone snooping on a public Wi-Fi network, can see every website you visit, modern solutions like DNS over HTTPS(DoH) and DNS over TLS(DoT) encrypt DNS traffic to solve this problem but they are not yet universally aadopted
5.DNS is comlex it has numerous record types amd strict formatting rules, a simple typo or misconfig in a zone file can have catastrophic consequences such as making a website unreaachable preventing email delivery or even taking an entire company offline
6.Although DNS is a distributed system, it has centralized choke points, the root of the system is managed by a single organization ICANN, this creates potential for censorship and control

what are registries?what is ICANN?
ICANN(International corporation for assigned names and numbers) is responsible for the coordination and maintenance of the central db relaated to the internet's namespaces and numerical spaces, it ensures stable and secure operation of the internet's unique identifier systems. It is responsible for managing the DNS root zone, which is the master list of all TLDs. It has the authority to delegate control of control each TLD to a specific organization, like verisign has a contract to run .com. ICANN is responsible for accepting all domain registrars, to become a registrar a company must meet ICANN's std and sign a contract agreeing to its policies. It develops policies on issues like who can own a domain, trademark issues etc.

Registries(domain name registry) are organization that have been given authority by ICANN to operate a TLD, they are the wholesale managers of a TLD and are responsible for maintaing the definitive master database of all domain names registered with it.They keep the official zone file for the tld which contains the list of all registered and the NS records pointing to the ANS for each domain Registries do not sell domains directly to the public, they work with the retail registrars, when we buy a domain from a registrar the registrar communicates with the registry to add your domain info to the master db.They can also set specific rules for its TLD.


what are name servers and authorative name servers?
A name server is any server that is part of the DNS, general term for a server that has DNS software installed and participates in the process of translating domain names into IP addresses, this  includes recursive resolvers(like our ISP's) and the root and tld server

Authoratative name server is the server that has the final say and holds the definitive original DNS records for a specific domain.



again to avoid the single point of failure, there are 13 root servers around the world, similarly there are multiple of each tld servers and ANS

now that we have introduced multiple servers, which server should our browser hit?
we need to chose the most efficient server which has least distance from us and less traffic, to know this someone has to maintain a running statistic

root server has the most traffic so it does the least compute, when someone hit its, it does not maintain any statistic, it just returns all the tld servers and its for us to figure out which one to choose, so someone has to maintain a statistic for tld servers, same applies for ANS

Now who has to maintain this statistic?
cant be the browser cause this statistic is continuosly evolvign so it is not a good idea for our browser to be continuosly keep looking for servers around the world and keep updating and even if we wnat to do this we cant cause first of all our browser is not on all the time and browser is not the only one sending requests, and one major problem is even if browser covers the statistics for our request who is goin to maintain for the response from server

same problems for the os also 

to solve this issue we have a special set of servers around the world called Recursive Resolvers(multiple servers around the world maintained by companies like google, cloudflare, etc)

A resolver is a general term for a client program that queries a name server. A DNS resolver is a resolver specifically designed to query the DNS. Recursive resolver describes the method the server uses to find a complete answer a specifc type of DNS resolver. Stub resolver is a very simple client side resolver that is paert of our device's os whose job is to take a query from an application and pass it to a recursive sesolver

when we want to send a request to google.com, the os talks to the recursive resolver which then talks to the root gets answer then tld gets answer then ANS gets answer and finally returns it to the os which then gives the answer to the browser

how will the os know where the recursive resolver(RR) is?
every device connected to the internet is configured with a default DNS resolver this is done is two ways, automatically via DHCP(when you connect to a Wi-Fi network, router automatically assigns your device an IP address and tells it if you need to look up a domain ask me, your router then forwards the request to ISP's DNS resolver, mkst common setup for home users) or manually configured(you can override the default setting and tell your os or browser to use a specific public dns resolver, popular choices include google's 1.1.1.1 or cloudflare's 8.8.8.8)

Once browser sends a query to its designated resolver that resolver acts as your agent and performs the full lookup process,
It checks its own cache to see if it already knows the answer 
If not it asks a root server, where can i find .com
root server directs it to a tld server
it asks the tld server where can i find google.com
tld server directs it to google's ANS
finally it asks google's name server what s ip for ww.google.com and get final answer back

SUMMARY
The entire step by step hourney from me typing google.com into my browser to the pge starting to load

1. Keystoke and browser cache: I type google.com and press enter, very first place browser looks is its own internal DNS cache, if ive visited goggle recently the ip address might be stored right there and process ends, lets assume its not
2. OS check: Browser makes a sys call to the OS's stub resolver. This is a small piece of client software not a full server. Its job is to check the local host's file, this is a simple text file on the computer that can manually map domain names to IP addresses, its a relic from the pre-dns era but is checked for legacy and local network cofig reasons. lets assume google.com is not in my host file
3. OS DNS cache: Stub resolver then checks the os level dns cache, os also keeps a temp list of recently resolved domain names, if tis found there ip is returd to browser and process ends. lets assume cache is empty
4. Preparing outbound query: the stub resolver now knows it must ask for outside help, it prepares a DNS query what is the AAAA record for google.com, its destination is the IP address of a recursive resolver
5. Finding resolver's address: How does my OS know the resolver's IP? when we connect to Wifi or LAN, our router usin a protocol called DHCP (dynamic host config protocol, this will be explained in other parts i guess cant be asked rn) gives our computer its local IP address, a subnet mask,  the router's own IP(the default gateway) and the IP address of one or more DNS resolvers, typically this is the IP address of a resolver  operated by your internet service provider(ISP)
6. Local network hop: Computer sends the DNS query packet, packet is addressed to the recursive resolver's IP, computer first seds it to the default gateway, which is the local router
7. ISP hop: router forwads the packet t your ISP's network, the ISP's infra routes the packet until it arrives at the designated recursive resolver server. This server oftem geographically close to you for speed
8. Recursive cache check: First resolver checks its own cache, since google.com is a popular domain its highly likely answer is already here, if so it immediately jumps to the final step of the return journey, lets assume cache is empty
9. Querying the root: the RR has a hardcoded list of 13 IP addresses for the root name servers, it sends its query to one of these root servers, i need ip for google.com. The resolver has 13 options, it dosent pick randomly, modern resolvers use complex algorithms primarily based on performance, they constantly measure the response time(latency) to each root server and will choose the one that is currently reponding fastest
10. Root server response: Root server dosent know ip for google.com but knows who manages .com tld and returns a list of the name servers for .com, critically it also includes their ip addresses in the same response, these are the first set of glue records, they are necessary as without them resolver would have to start a new search for the IP creating a circular problem
11. Querying the TLD: Recursive resolver now has a list of .com TLDs servers and their IPs, just like with root server resolver will choose the fastest responding server from this list based on ongoing performance tracking , it sends a query to that TLD server's ip, i need the ip for google.com
12. TLD server response: .com TLD server dosent know the final IP either, it checks its db and finds the delegation for google.com, and gives the response including the authoratative name servers in charge of google.com.
13. Querying the Authoratative Name Server(ANS): The recursive resolver now has the exact IP address of the server that holds the definitive answer, it again chooses the best performing server from the list rpovided by TLD and sends final query i need AAAA record for google.com
14. Authoratative Server Response: This is the server that google's admin manage, it looks in its zone file and finds the AAAA record for google.com, it gives the final authoritative answer.
15. Caching the result: The recursive resolver receives the IP address and immediately stores this in its cache, along with its TTL(time to live)value, any other query for google.com in the next TTL time will be answered instantly from this cache.
16. Response to computer: resolver sends the dns response packet containing the ip address back to our computer. It travels back through the ISP's network to our router, which then forwards it our specific machine on the local network.
17. OS and browser receive IP: The stub resolver in OS receives the answer, it caches the result and passes the IP address to your web browser
18. Browser action: Browser now has the destination IP address, the entire DNS lookup process is complete
19. Initiating HTTP/HTTPS: browser opens a TCP connection to that IP address on port 443 for https and begins sending http requests to google's web server to fetch the webpage content, connection to the website has now begun


Glossary
DHCP - a network protocol that automatically assigns IP addresses and other crucial network info(like subnet mask and default gateway) to devices as they connect to a network
Gateway - a device typically a router that acts as a bridge b/w 2 diff networks, its the entry and exit point for data traffic leaving one network to go to another
Default gateway - specific ip address of the gateway that devices on a network use by default when trying to send data to a device on another network
Local IP address - a private ip addressassigned to a device within a local network, this address is used for comms b/w devices on the same network and is not reachable from the public internet
Subnet mask - a number that splits an ip address into 2 parts - network address and host address, helps device determine whether another IP address is on the same local network or an external network
