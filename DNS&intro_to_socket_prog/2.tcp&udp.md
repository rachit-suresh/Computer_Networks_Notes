TCP
Transmission control protocol

a connection oriented(before both devices talk to each other they establish a connection, they have to ensure both sides are ready to accept and send data) protocol which is used for reliable data delivery(if one side sends something and it gets corrupted in b/w then the other side will never send an acknowledgemnet so the sender sends it again after a while)

3 way handshake

Client                              Server
      1.Sync Packet
      (Hello)
  ------------------------------------>

      2.Sync acknoledgement packet
      (i am acknoledging your hello)
  <------------------------------------

      3.Acknoledgement packet
      (i am ack your ack)
  ------------------------------------>

if only the first 2 exists then the client knows that server can send a response to a request but not vice versa

# purpose of 3 way handshake is not just to establish this connection, there is one more reason is to exchange sequence nos and all, google about it
The other critical purpose is to synchronize the initial sequence numbers between client and server, this is the foundation for TCP's ability to provide reliable in order data delivery

Role of sequence numbers - when we are sending a large file, tcp breaks it into chunks called segments, the problem is that these segments can arive out of order, get duplicated or be lost entirely on their journey across the internet. To solve this, TCP adds a sequence number (SEQ) to each segment, this number acts like a page number in a book allowing receiving device to reassemble the segments in correct order, identify and request any missing segments and discard aany duplicate segments

3 way handshake in detail 

our computer wants to connect to a server, initial sequence numbers are chosen randomly for security.
1.SYN(synchronise) - computer sends first packet
    flag - SYN flag is set to 1(i want to connect and sync)
    client's SEQ - it picks a random initial seq number, lets say SEQ=100, this packet essentially says hi i'd like to start a connection, my first piece of data will be numbered 100
2.SYN-ACK(synchronize-acknowledgement) - server receives the request and sends a response
    flags - both SYN and ACK flags are set to 1
    server's SEQ - server picks its own random initial sequence number, say SEQ=300
    server's ACK - ackowledges client's number by adding one to it: ACK=101(100+1)
    This packet says , i hear you and agree to connect, my first piece of data will be numbered 300, and now i am expecting your data numbered 101
3.ACK(ackownlegment) - our comp receives the server's response and sends one final packet to complete the connection
    flags - ACK flag is set to 1
    client's SEQ - sends its next sequence number which is SEQ=101
    client's ACK - acknowleges server's seq number by adding one:ACK=301
    This final packet says, got it, im expecting your data numbered 301.

A TCP seq number is 32-bit unsigned integer, this allows for a total of 4 GB of data before numbers run out, its normal and expected part of tcp's design to exceed its limit the mechanism to handle this is called seq num wrap around(tcp treats seq numbers not as a straight line but as a circle, next number after max value is 0, but now how does a server know that a packet with SEQ=100 is a new packet and not a very old delayed packet from the previous time the seq was at 100? The system is designed with a crucial safeguard based on Maximum Segment Lifetime(MSL)(MSL is a defined time limit that a TCP segment is allowed to exist on the internet before being discarded, its conservatively set to around 2 minuted, in 1980s TCP was designed so that on any given connection the seq numbers cannot wrap around faster than the MSL since network speeds were really slow,  on modern multi gigabit ntworks, the seq number space can be exhausted in a few seconds which is much faster than the 2 minute MSL the problem was solved with an update that introduced the TCP timestamps option(when this option is enabled every single TCP packet gets an extra field containing a constantly incrasing value) and the PAWS algorithm(protection against wrapped sequence numbers algo is a simple rule that receiving computer follows, i will only accept a packet if its timestamp is newer than the last valid timestamp ive seen for this connection)))


## Three-Way Handshake with Timestamps
The TCP Timestamps option is negotiated during the handshake. It involves two fields: a timestamp value (TSval) and a timestamp echo reply (TSecr).
    SYN (Synchronize): Your computer (the client) initiates the connection.
        Flags: SYN
        Sequence Number: SEQ=100 (random)
        Timestamp Option: The client sends its current timestamp value. TSval=8000. The echo field is empty.
        Meaning: "Hi, I want to connect. My sequence starts at 100, and my current clock time is 8000."
    SYN-ACK (Synchronize-Acknowledge): The server receives the packet and responds.
        Flags: SYN, ACK
        Sequence Number: SEQ=300 (server's random number)
        Acknowledgement Number: ACK=101 (client's SEQ + 1)
        Timestamp Option: The server sends its own current timestamp (TSval=55000) and echoes the client's timestamp back (TSecr=8000).
        Meaning: "I agree. My sequence starts at 300, I'm expecting your data 101, my clock is at 55000, and I'm acknowledging I saw your clock at 8000."
    ACK (Acknowledge): The client receives the response and sends the final packet.
        Flags: ACK
        Sequence Number: SEQ=101
        Acknowledgement Number: ACK=301 (server's SEQ + 1)
        Timestamp Option: The client sends its new timestamp (TSval=8005) and echoes the server's timestamp back (TSecr=55000).
        Meaning: "Connection established. My clock is now at 8005, and I'm acknowledging I saw your clock at 55000."
    The connection is now active, and both sides will continue sending and echoing timestamps in every subsequent packet, which allows them to calculate the Round-Trip Time (RTT) and protect against wrapped sequence numbers (PAWS).
## Handling an Error During the Handshake
Let's imagine the server's SYN-ACK packet gets corrupted on its way to you.
Corruption and Checksum Failure: Every TCP packet has a checksum, which is a calculated value based on the packet's contents. When your computer receives the corrupted SYN-ACK packet, it performs its own checksum calculation. The result will not match the checksum value in the packet's header. Your computer knows the packet is damaged and immediately discards it. It does not send any "error" message back.
The Retransmission Timeout (RTO): After the client sent its initial SYN packet, it started a timer called the Retransmission Timeout (RTO). It's now waiting for the SYN-ACK response from the server. Since the corrupted packet was dropped, no response ever arrives.
Timeout and Retransmission: The RTO timer expires (this can be a few seconds). Since the client hasn't received the expected SYN-ACK, it assumes the original SYN packet was lost and retransmits the exact same SYN packet again.

## Retransmission Limits
Operating systems have a configurable limit on how many times they will retransmit the initial SYN packet. A common default value for this limit is 5 or 6 retries.  
This means the client will send the initial SYN and then re-send it a set number of times if it doesn't receive the SYN-ACK response. If it still gets no reply after the final attempt, the OS gives up.
## Exponential Backoff
The client doesn't just rapidly send these retries one after another. Doing so could contribute to the very network congestion that might be causing the problem in the first place. Instead, it uses a crucial algorithm called Exponential Backoff.  
This means the waiting period, or Retransmission Timeout (RTO), doubles after each failed attempt.
Here’s a typical sequence:
Initial attempt: Client sends SYN. Waits 1 second. No reply.  
Retry 1: Client re-sends SYN. Waits 2 seconds. No reply.
Retry 2: Client re-sends SYN. Waits 4 seconds. No reply.
Retry 3: Client re-sends SYN. Waits 8 seconds. No reply.
...and so on.

## Final Result: Connection Failure
If the client completes all its retransmission attempts (with the exponentially increasing delays) and still has not received a SYN-ACK, the operating system's networking stack will stop trying.
It will then report an error back to the application that requested the connection (e.g., your web browser). This is when you see a user-facing error message like:
"This site can’t be reached"
"Connection timed out"

A checksum is a small, calculated value that is used to detect errors that may have been introduced during the transmission or storage of data. Its entire purpose is to verify the integrity of data by checking if it has been accidentally corrupted.
The core principle is that the checksum is a mathematical signature of the data. If even a single bit of the data changes, the signature will change, revealing the error.
## How a Checksum Works
Think of it like summing a list of numbers.
Sender's Calculation: A sender has a block of data, which can be treated as a sequence of numbers. It performs a specific mathematical operation (the "checksum function") on these numbers to produce a result. For example, it might just add them all up. This result is the checksum.
Transmission: The sender attaches this checksum to the original data and sends both together.
Receiver's Calculation: The receiver gets the data and the sender's checksum. It performs the exact same mathematical operation on the data it received to calculate its own checksum.
Verification: The receiver compares the checksum it just calculated with the checksum it received from the sender.
If they match, the data is considered intact.
If they do not match, the receiver knows the data was corrupted in transit and discards it.
The actual TCP checksum uses a more robust method called 1s' Complement addition on 16-bit chunks of the data, but the principle of calculating, sending, and verifying is exactly the same.


| Feature               | Checksum (e.g., TCP Checksum)  | Cryptographic Hash (e.g., SHA-256)   |

| Primary Goal          | Error Detection                | Security & Integrity Verification    |
| Protects Against      | Accidental Corruption          | Malicious Tampering                  |
| Speed                 | Very Fast                      | Slower                               |
| Collision Resistance  | Very Low (Not a design goal)   | Very High (A primary design goal)    |
| Typical Use Case      | Network data transfer (TCP/IP) | Digital signatures, password storage |

## Example: Corruption and Retransmission with Timestamps
This scenario happens after a successful three-way handshake where the TCP Timestamps option was enabled.
### Step 1: Client Sends Data
Your computer (the client) sends a packet containing 500 bytes of data to a web server.
Sequence Number: SEQ=501 (Let's say the last packet ended at byte 500).
Timestamp Option: The client includes its current timestamp (TSval=9400) and echoes the server's last seen timestamp (TSecr=62000).
Checksum: A checksum is calculated based on the packet's header and the 500 bytes of data.
### Step 2: Corruption and Detection
During transit, network interference flips a bit in the data payload. When the packet arrives at the server, its networking stack recalculates the checksum based on the corrupted data it received. This new checksum does not match the checksum in the packet's header. The server immediately knows the packet is damaged and discards it. It sends no acknowledgment for this data.
### Step 3: Timeout and Retransmission
The client, having sent the data, started a Retransmission Timeout (RTO) timer. It is waiting for an acknowledgment from the server for the data it sent (it expects an ACK=1001).
Because the server discarded the corrupted packet, this acknowledgment never comes.
The client's RTO timer expires. The client assumes the packet was lost.
### Step 4: Resending the Packet with a New Timestamp
The client prepares to resend the exact same 500 bytes of data.
Sequence Number: SEQ=501 (This must be the same because it's the same data).
Timestamp Option: This is the key difference. The client does not reuse the old timestamp of 9400. Time has passed, so it inserts its new, current timestamp, TSval=9405.
Checksum: A fresh checksum is calculated for this new packet.
This retransmitted packet is sent. If it arrives intact, the server's checksum calculation will succeed, it will process the data, and it will finally send the ACK=1001 that the client has been waiting for.

## How the Server Handles the Duplicate
If the server's acknowledgment gets lost or corrupted, the client's Retransmission Timeout (RTO) timer will expire, and the client will simply resend the data.


The client's RTO expires and it resends the packet.
    Sequence Number: SEQ=101 (This is the same).
    Timestamp: TSval=8015 (This is new and higher than the original's timestamp).
The server receives this retransmitted packet. It performs two key checks:
    PAWS Check: It looks at the timestamp. Since 8015 is newer than the last valid timestamp it saw for this connection, the packet is considered "fresh" and is not a stray from the past. The PAWS check passes.
    Sequence Number Check: It then looks at the sequence number, SEQ=101. It checks its records and sees it has already received and processed the data for this sequence.
The server's conclusion is: "This packet is new, not an old ghost (timestamp is valid), but the data it contains is a duplicate of something I already have (sequence number is old). This means my last acknowledgment must have been lost."

Based on this, the server discards the duplicate data payload and simply resends the acknowledgment (ACK=201).

UDP
User Datagram Protocol

connectionless protocol that prioritizes speed over reliability\


UDP strips away almost all of the complex features we discussed for TCP.
Connectionless (No Handshake): UDP does not establish a connection. There is no three-way handshake before sending data and no formal teardown process. The first packet you send is your data. This saves time and overhead, a feature known as "low latency."  
Unreliable (No ACKs or Retransmissions): This is the biggest difference. UDP provides no guarantee of delivery.  
It does not use acknowledgments (ACKs).  
It does not have a Retransmission Timeout (RTO) or a mechanism to resend lost packets.  
If a packet is dropped, it's gone for good. Reliability must be handled by the application itself, if needed.  
**No Ordering (No Sequence Numbers): UDP packets, called datagrams, are sent as independent units. They have no sequence numbers. If Packet A is sent before Packet B, they could arrive as B then A, or A could be lost entirely. UDP does nothing to reorder them.  
No Flow or Congestion Control: UDP has no concept of a sliding window or complex algorithms to manage network congestion. It sends data as fast as the application generates it, which is sometimes called "blasting" data. This can be efficient but also risks overwhelming the network if not managed carefully by the application.  
Simple Header: A UDP header is a fixed, tiny 8 bytes, compared to TCP's header which is 20 bytes or more (due to options like timestamps). This is because it doesn't need fields for sequence numbers, acknowledgment numbers, or window sizes.
  
## Similarities to TCP
Despite their vast differences, they share a couple of fundamental roles.
Transport Layer and Port Numbers: Like TCP, UDP operates at the transport layer. Its main job is to get data from a specific application on one computer to a specific application on another. It accomplishes this using port numbers (e.g., DNS uses UDP port 53, and many online games use UDP for game data).  
Checksum for Integrity: UDP also has a checksum field in its header. Its purpose is the same as in TCP: to detect if the data has been accidentally corrupted during transit. If the checksum fails, the packet is discarded.

